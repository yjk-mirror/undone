# Undone Engine Scaffold — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use `superpowers:executing-plans` to implement this plan task-by-task.

**Goal:** Build a compiling Rust workspace with all domain types, pack loading,
the expression parser, scene deserialization, and a minimal eframe window — a
clean foundation every future session builds on.

**Architecture:** Cargo workspace with 7 crates, strict dependency direction
(`undone-domain` → `undone-world` → `undone-scene` → `undone-ui`). World owns
all game state via SlotMap. Expression conditions parsed to a typed AST at pack
load time — never evaluated as strings at runtime.

**Tech Stack:** Rust stable, egui/eframe 0.31, slotmap 1.0, lasso 0.7,
minijinja 2, serde + serde_json + toml, lasso for string interning.

**Reference:** `docs/plans/2026-02-21-engine-design.md` — living document,
treat as context not gospel. Deviate when implementation reveals a better path;
update the design doc when you do.

**Working directory for all commands:** `C:/Users/YJK/dev/mirror/undone/`

---

## Task 1: Workspace Root

**Files:**
- Create: `Cargo.toml`
- Create: `src/main.rs`

**Step 1: Write workspace Cargo.toml**

```toml
# Cargo.toml (workspace root)
[workspace]
members = [
    "crates/undone-domain",
    "crates/undone-world",
    "crates/undone-packs",
    "crates/undone-expr",
    "crates/undone-scene",
    "crates/undone-save",
    "crates/undone-ui",
    ".",
]
resolver = "2"

[workspace.dependencies]
# Serialisation
serde       = { version = "1",    features = ["derive"] }
serde_json  = "1"
toml        = "0.8"

# Data structures
slotmap     = { version = "1",    features = ["serde"] }
lasso       = { version = "0.7",  features = ["serialize"] }
indexmap    = "2"

# Template rendering
minijinja   = "2"

# GUI
eframe      = "0.31"
egui        = "0.31"

# Error handling
thiserror   = "2"
anyhow      = "1"

# Logging
tracing            = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

[package]
name    = "undone"
version = "0.1.0"
edition = "2021"

[dependencies]
undone-domain = { path = "crates/undone-domain" }
undone-world  = { path = "crates/undone-world" }
undone-packs  = { path = "crates/undone-packs" }
undone-scene  = { path = "crates/undone-scene" }
undone-ui     = { path = "crates/undone-ui" }
eframe        = { workspace = true }
anyhow        = { workspace = true }
tracing-subscriber = { workspace = true }
```

**Step 2: Write placeholder main.rs**

```rust
// src/main.rs
fn main() {
    println!("Undone — starting up");
}
```

**Step 3: Create each crate**

Run for each crate name in this list:
`undone-domain`, `undone-world`, `undone-packs`, `undone-expr`,
`undone-scene`, `undone-save`, `undone-ui`

```bash
mkdir -p crates/undone-domain/src
```

Create `crates/undone-domain/Cargo.toml`:
```toml
[package]
name    = "undone-domain"
version = "0.1.0"
edition = "2021"

[dependencies]
serde    = { workspace = true }
slotmap  = { workspace = true }
lasso    = { workspace = true }
```

Create `crates/undone-domain/src/lib.rs`:
```rust
// placeholder
```

Repeat for each crate. Dependency lists per crate:

**undone-world:**
```toml
[dependencies]
undone-domain = { path = "../undone-domain" }
serde         = { workspace = true }
slotmap       = { workspace = true }
```

**undone-packs:**
```toml
[dependencies]
undone-domain = { path = "../undone-domain" }
undone-world  = { path = "../undone-world" }
serde         = { workspace = true }
toml          = { workspace = true }
lasso         = { workspace = true }
thiserror     = { workspace = true }
anyhow        = { workspace = true }
```

**undone-expr:**
```toml
[dependencies]
undone-domain = { path = "../undone-domain" }
undone-world  = { path = "../undone-world" }
thiserror     = { workspace = true }
```

**undone-scene:**
```toml
[dependencies]
undone-domain = { path = "../undone-domain" }
undone-world  = { path = "../undone-world" }
undone-packs  = { path = "../undone-packs" }
undone-expr   = { path = "../undone-expr" }
serde         = { workspace = true }
toml          = { workspace = true }
minijinja     = { workspace = true }
thiserror     = { workspace = true }
anyhow        = { workspace = true }
```

**undone-save:**
```toml
[dependencies]
undone-domain = { path = "../undone-domain" }
undone-world  = { path = "../undone-world" }
serde         = { workspace = true }
serde_json    = { workspace = true }
thiserror     = { workspace = true }
```

**undone-ui:**
```toml
[dependencies]
undone-domain = { path = "../undone-domain" }
undone-world  = { path = "../undone-world" }
undone-scene  = { path = "../undone-scene" }
undone-packs  = { path = "../undone-packs" }
egui          = { workspace = true }
eframe        = { workspace = true }
```

**Step 4: Verify workspace compiles clean**

```bash
cargo build
```

Expected: compiles with zero errors. Warnings about empty lib.rs are fine.

**Step 5: Commit**

```bash
git add .
git commit -m "scaffold: initialize Cargo workspace with 7 crates"
```

---

## Task 2: Engine-Level Enums (`undone-domain`)

**Files:**
- Create: `crates/undone-domain/src/enums.rs`
- Modify: `crates/undone-domain/src/lib.rs`

**Step 1: Write the enums**

Create `crates/undone-domain/src/enums.rs`:

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum ArousalLevel {
    Discomfort,
    Comfort,
    Enjoy,
    Close,
    Orgasm,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum AlcoholLevel {
    Sober,
    Tipsy,
    Drunk,
    VeryDrunk,
    MaxDrunk,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum LikingLevel {
    Neutral,
    Ok,
    Like,
    Close,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum LoveLevel {
    None,
    Some,
    Confused,
    Crush,
    Love,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum AttractionLevel {
    Unattracted,
    Ok,
    Attracted,
    Lust,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Behaviour {
    Neutral,
    Romantic,
    Mean,
    Cold,
    Faking,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum RelationshipStatus {
    Stranger,
    Acquaintance,
    Friend,
    Partner { cohabiting: bool },
    Married,
    Ex,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PlayerFigure {
    Slim,
    Toned,
    Womanly,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum MaleFigure {
    Average,
    Skinny,
    Toned,
    Muscular,
    Thickset,
    Paunchy,
    Fat,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum BreastSize {
    Small,
    MediumSmall,
    MediumLarge,
    Large,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Age {
    LateTeen,
    EarlyTwenties,
    Twenties,
    LateTwenties,
    Thirties,
    Forties,
    Fifties,
    Old,
}
```

**Step 2: Export from lib.rs**

```rust
// crates/undone-domain/src/lib.rs
pub mod enums;
pub use enums::*;
```

**Step 3: Write tests**

Add to `crates/undone-domain/src/enums.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn arousal_ordering() {
        assert!(ArousalLevel::Orgasm > ArousalLevel::Discomfort);
        assert!(ArousalLevel::Enjoy > ArousalLevel::Comfort);
        assert!(ArousalLevel::Close < ArousalLevel::Orgasm);
    }

    #[test]
    fn relationship_partner_carries_data() {
        let r = RelationshipStatus::Partner { cohabiting: true };
        assert_eq!(r, RelationshipStatus::Partner { cohabiting: true });
        assert_ne!(r, RelationshipStatus::Partner { cohabiting: false });
    }

    #[test]
    fn serde_roundtrip() {
        let level = ArousalLevel::Close;
        let json  = serde_json::to_string(&level).unwrap();
        let back: ArousalLevel = serde_json::from_str(&json).unwrap();
        assert_eq!(level, back);
    }
}
```

**Step 4: Run tests**

```bash
cargo test -p undone-domain
```

Expected: 3 tests pass.

**Step 5: Commit**

```bash
git add crates/undone-domain/
git commit -m "domain: add engine-level enums with ordering and serde"
```

---

## Task 3: Content ID Types (`undone-domain`)

**Files:**
- Create: `crates/undone-domain/src/ids.rs`
- Modify: `crates/undone-domain/src/lib.rs`

**Step 1: Write ID newtypes**

```rust
// crates/undone-domain/src/ids.rs
use lasso::Spur;
use serde::{Deserialize, Serialize};

/// A player trait ID — e.g. "SHY", "POSH"
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TraitId(pub Spur);

/// An NPC trait ID — e.g. "CHARMING", "VIRILE"
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct NpcTraitId(pub Spur);

/// A player skill ID — e.g. "FITNESS", "CHARM"
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct SkillId(pub Spur);

/// A personality ID — e.g. "JERK", "CARING"
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct PersonalityId(pub Spur);

/// A character type ID (female NPCs) — e.g. "PARTY_GIRL", "INNOCENT"
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct CharTypeId(pub Spur);

/// An inventory item ID — e.g. "CONDOMS", "GYM_MEMBERSHIP"
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct StuffId(pub Spur);

/// A named stat ID — e.g. "WEEKS_SINCE_SEX", "ALL_ORGASMS"
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct StatId(pub Spur);

/// A scene ID — e.g. "base::rain_shelter"
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct SceneId(pub String);   // scene IDs are not interned (too varied)

impl SceneId {
    pub fn new(s: impl Into<String>) -> Self {
        Self(s.into())
    }
}

impl std::fmt::Display for SceneId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}
```

**Step 2: Export from lib.rs**

```rust
// crates/undone-domain/src/lib.rs
pub mod enums;
pub mod ids;
pub use enums::*;
pub use ids::*;
```

**Step 3: Run build**

```bash
cargo build -p undone-domain
```

Expected: clean compile.

**Step 4: Commit**

```bash
git add crates/undone-domain/
git commit -m "domain: add content ID newtypes (TraitId, SkillId, etc.)"
```

---

## Task 4: Player Struct (`undone-domain`)

**Files:**
- Create: `crates/undone-domain/src/player.rs`
- Modify: `crates/undone-domain/src/lib.rs`

**Step 1: Write Player and supporting types**

```rust
// crates/undone-domain/src/player.rs
use std::collections::{HashMap, HashSet};
use serde::{Deserialize, Serialize};
use slotmap::DefaultKey;
use crate::{
    ArousalLevel, AlcoholLevel, BreastSize, PlayerFigure, Age,
    TraitId, SkillId, StuffId,
};

/// A reference to any NPC (male or female) by their SlotMap key.
/// The World figures out which map to look in via the MaleNpcKey/FemaleNpcKey
/// wrapper types.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum NpcKey {
    Male(MaleNpcKey),
    Female(FemaleNpcKey),
}

slotmap::new_key_type! {
    pub struct MaleNpcKey;
    pub struct FemaleNpcKey;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SkillValue {
    pub value: i32,
    pub modifier: i32,
}

impl SkillValue {
    pub fn effective(&self) -> i32 {
        self.value + self.modifier
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PregnancyState {
    pub weeks: u32,
    pub father_key: Option<NpcKey>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Player {
    // Identity
    pub name: String,
    pub age: Age,
    pub race: String,
    pub figure: PlayerFigure,
    pub breasts: BreastSize,
    pub eye_colour: String,
    pub hair_colour: String,

    // Content-driven (loaded from pack data files, not hardcoded)
    pub traits: HashSet<TraitId>,
    pub skills: HashMap<SkillId, SkillValue>,

    // Economy & wellbeing
    pub money: i32,
    pub stress: i32,
    pub anxiety: i32,
    pub arousal: ArousalLevel,
    pub alcohol: AlcoholLevel,

    // Relationships (keys into World's NPC maps)
    pub partner: Option<NpcKey>,
    pub friends: Vec<NpcKey>,

    // Life state
    pub virgin: bool,
    pub anal_virgin: bool,
    pub lesbian_virgin: bool,
    pub on_pill: bool,
    pub pregnancy: Option<PregnancyState>,

    // Inventory
    pub stuff: HashSet<StuffId>,

    // Per-character scene memory (custom per-scene flags on the player)
    pub custom_flags: HashMap<String, String>,
    pub custom_ints: HashMap<String, i32>,

    // Transformation axis
    pub always_female: bool,  // false = male-start PC
    pub femininity: i32,      // 0–100, starts low for male-start
}

impl Player {
    pub fn has_trait(&self, id: TraitId) -> bool {
        self.traits.contains(&id)
    }

    pub fn skill(&self, id: SkillId) -> i32 {
        self.skills.get(&id).map(|s| s.effective()).unwrap_or(0)
    }

    pub fn is_drunk(&self) -> bool {
        self.alcohol >= AlcoholLevel::Drunk
    }

    pub fn is_very_drunk(&self) -> bool {
        self.alcohol >= AlcoholLevel::VeryDrunk
    }

    pub fn is_max_drunk(&self) -> bool {
        self.alcohol == AlcoholLevel::MaxDrunk
    }
}
```

**Step 2: Export**

Add to `crates/undone-domain/src/lib.rs`:
```rust
pub mod player;
pub use player::{Player, NpcKey, MaleNpcKey, FemaleNpcKey, SkillValue, PregnancyState};
```

**Step 3: Write tests**

Add to `crates/undone-domain/src/player.rs`:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    fn make_player() -> Player {
        Player {
            name: "Eva".into(),
            age: Age::LateTeen,
            race: "east_asian".into(),
            figure: PlayerFigure::Slim,
            breasts: BreastSize::Large,
            eye_colour: "brown".into(),
            hair_colour: "dark".into(),
            traits: HashSet::new(),
            skills: HashMap::new(),
            money: 500,
            stress: 0,
            anxiety: 0,
            arousal: ArousalLevel::Comfort,
            alcohol: AlcoholLevel::Sober,
            partner: None,
            friends: vec![],
            virgin: true,
            anal_virgin: true,
            lesbian_virgin: true,
            on_pill: false,
            pregnancy: None,
            stuff: HashSet::new(),
            custom_flags: HashMap::new(),
            custom_ints: HashMap::new(),
            always_female: false,
            femininity: 10,
        }
    }

    #[test]
    fn drunk_checks_respect_ordering() {
        let mut p = make_player();
        assert!(!p.is_drunk());
        p.alcohol = AlcoholLevel::Drunk;
        assert!(p.is_drunk());
        assert!(!p.is_very_drunk());
        p.alcohol = AlcoholLevel::MaxDrunk;
        assert!(p.is_very_drunk());
        assert!(p.is_max_drunk());
    }

    #[test]
    fn skill_effective_adds_modifier() {
        let mut p = make_player();
        // We can't easily make a SkillId without a Rodeo here,
        // so just test SkillValue directly
        let sv = SkillValue { value: 50, modifier: -10 };
        assert_eq!(sv.effective(), 40);
    }
}
```

**Step 4: Run tests**

```bash
cargo test -p undone-domain
```

Expected: all tests pass.

**Step 5: Commit**

```bash
git add crates/undone-domain/
git commit -m "domain: add Player struct with trait/skill lookup helpers"
```

---

## Task 5: NPC Structs (`undone-domain`)

**Files:**
- Create: `crates/undone-domain/src/npc.rs`
- Modify: `crates/undone-domain/src/lib.rs`

**Step 1: Write NpcCore, MaleNpc, FemaleNpc**

```rust
// crates/undone-domain/src/npc.rs
use std::collections::{HashMap, HashSet};
use serde::{Deserialize, Serialize};
use crate::{
    ArousalLevel, AlcoholLevel, AttractionLevel, Behaviour,
    BreastSize, LikingLevel, LoveLevel, MaleFigure, PersonalityId,
    CharTypeId, NpcTraitId, PlayerFigure, PregnancyState, RelationshipStatus,
    MaleNpcKey,
};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NpcCore {
    pub name: String,
    pub age: crate::Age,
    pub race: String,
    pub eye_colour: String,
    pub hair_colour: String,
    pub personality: PersonalityId,
    pub traits: HashSet<NpcTraitId>,

    // Relationship state
    pub relationship: RelationshipStatus,
    pub pc_liking: LikingLevel,      // PC's liking of NPC
    pub npc_liking: LikingLevel,     // NPC's liking of PC
    pub pc_love: LoveLevel,
    pub npc_love: LoveLevel,
    pub pc_attraction: AttractionLevel,
    pub npc_attraction: AttractionLevel,
    pub behaviour: Behaviour,

    // Memory
    pub relationship_flags: HashSet<String>,
    pub sexual_activities: HashSet<String>,
    pub custom_flags: HashMap<String, String>,
    pub custom_ints: HashMap<String, i32>,
    pub knowledge: i32,

    pub contactable: bool,
    pub arousal: ArousalLevel,
    pub alcohol: AlcoholLevel,
}

impl NpcCore {
    pub fn has_trait(&self, id: NpcTraitId) -> bool {
        self.traits.contains(&id)
    }

    pub fn is_partner(&self) -> bool {
        matches!(
            self.relationship,
            RelationshipStatus::Partner { .. } | RelationshipStatus::Married
        )
    }

    pub fn is_friend(&self) -> bool {
        self.relationship == RelationshipStatus::Friend
    }

    pub fn is_cohabiting(&self) -> bool {
        matches!(
            self.relationship,
            RelationshipStatus::Partner { cohabiting: true } | RelationshipStatus::Married
        )
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaleClothing {
    pub trousers_worn: bool,
    pub trousers_open: bool,
    pub shirt_worn: bool,
    pub shirt_open: bool,
    pub jacket_worn: bool,
    pub jacket_open: bool,
    pub has_condom: bool,
    pub wearing_condom: bool,
}

impl Default for MaleClothing {
    fn default() -> Self {
        Self {
            trousers_worn: true,
            trousers_open: false,
            shirt_worn: true,
            shirt_open: false,
            jacket_worn: false,
            jacket_open: false,
            has_condom: false,
            wearing_condom: false,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaleNpc {
    pub core: NpcCore,
    pub figure: MaleFigure,
    pub clothing: MaleClothing,
    pub had_orgasm: bool,
    pub has_baby_with_pc: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FemaleClothing {
    pub bra_worn: bool,
    pub top_worn: bool,
    pub bottom_worn: bool,
    pub panties_worn: bool,
    pub legwear_worn: bool,
}

impl Default for FemaleClothing {
    fn default() -> Self {
        Self {
            bra_worn: true,
            top_worn: true,
            bottom_worn: true,
            panties_worn: true,
            legwear_worn: false,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FemaleNpc {
    pub core: NpcCore,
    pub char_type: CharTypeId,
    pub figure: PlayerFigure,
    pub breasts: BreastSize,
    pub clothing: FemaleClothing,
    pub pregnancy: Option<PregnancyState>,
    pub virgin: bool,
}
```

**Step 2: Export**

Add to `crates/undone-domain/src/lib.rs`:
```rust
pub mod npc;
pub use npc::{NpcCore, MaleNpc, FemaleNpc, MaleClothing, FemaleClothing};
```

**Step 3: Write tests**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_partner_matches_married_and_partner_variants() {
        // We can't make NpcCore without a lasso Rodeo, so test the method logic
        // by checking the match arms compile correctly — integration tests will
        // cover the full path
        let r1 = RelationshipStatus::Partner { cohabiting: false };
        let r2 = RelationshipStatus::Married;
        let r3 = RelationshipStatus::Friend;
        assert!(matches!(r1, RelationshipStatus::Partner { .. } | RelationshipStatus::Married));
        assert!(matches!(r2, RelationshipStatus::Partner { .. } | RelationshipStatus::Married));
        assert!(!matches!(r3, RelationshipStatus::Partner { .. } | RelationshipStatus::Married));
    }

    #[test]
    fn male_clothing_default_is_dressed() {
        let c = MaleClothing::default();
        assert!(c.trousers_worn);
        assert!(c.shirt_worn);
        assert!(!c.wearing_condom);
    }
}
```

**Step 4: Run tests**

```bash
cargo test -p undone-domain
```

Expected: all tests pass.

**Step 5: Commit**

```bash
git add crates/undone-domain/
git commit -m "domain: add NpcCore, MaleNpc, FemaleNpc structs"
```

---

## Task 6: World Struct (`undone-world`)

**Files:**
- Create: `crates/undone-world/src/lib.rs`
- Create: `crates/undone-world/src/game_data.rs`

**Step 1: Write GameData**

```rust
// crates/undone-world/src/game_data.rs
use std::collections::{HashMap, HashSet};
use serde::{Deserialize, Serialize};
use undone_domain::StatId;

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GameData {
    pub flags: HashSet<String>,
    pub stats: HashMap<StatId, i32>,
    pub job_title: String,
    pub allow_anal: bool,
    pub week: u32,
}

impl GameData {
    pub fn has_flag(&self, flag: &str) -> bool {
        self.flags.contains(flag)
    }

    pub fn set_flag(&mut self, flag: impl Into<String>) {
        self.flags.insert(flag.into());
    }

    pub fn remove_flag(&mut self, flag: &str) {
        self.flags.remove(flag);
    }

    pub fn get_stat(&self, id: StatId) -> i32 {
        self.stats.get(&id).copied().unwrap_or(0)
    }

    pub fn add_stat(&mut self, id: StatId, amount: i32) {
        *self.stats.entry(id).or_insert(0) += amount;
    }

    pub fn set_stat(&mut self, id: StatId, value: i32) {
        self.stats.insert(id, value);
    }
}
```

**Step 2: Write World**

```rust
// crates/undone-world/src/lib.rs
pub mod game_data;
pub use game_data::GameData;

use serde::{Deserialize, Serialize};
use slotmap::SlotMap;
use undone_domain::{MaleNpcKey, FemaleNpcKey, MaleNpc, FemaleNpc, Player};

#[derive(Debug, Serialize, Deserialize)]
pub struct World {
    pub player: Player,
    pub male_npcs: SlotMap<MaleNpcKey, MaleNpc>,
    pub female_npcs: SlotMap<FemaleNpcKey, FemaleNpc>,
    pub game_data: GameData,
}

impl World {
    pub fn male_npc(&self, key: MaleNpcKey) -> Option<&MaleNpc> {
        self.male_npcs.get(key)
    }

    pub fn male_npc_mut(&mut self, key: MaleNpcKey) -> Option<&mut MaleNpc> {
        self.male_npcs.get_mut(key)
    }

    pub fn female_npc(&self, key: FemaleNpcKey) -> Option<&FemaleNpc> {
        self.female_npcs.get(key)
    }

    pub fn female_npc_mut(&mut self, key: FemaleNpcKey) -> Option<&mut FemaleNpc> {
        self.female_npcs.get_mut(key)
    }
}
```

**Step 3: Run build**

```bash
cargo build -p undone-world
```

Expected: clean compile.

**Step 4: Commit**

```bash
git add crates/undone-world/
git commit -m "world: add World struct and GameData with flag/stat helpers"
```

---

## Task 7: Pack System — Manifest & Data Files (`undone-packs`)

**Files:**
- Create: `crates/undone-packs/src/lib.rs`
- Create: `crates/undone-packs/src/manifest.rs`
- Create: `crates/undone-packs/src/data.rs`
- Create: `packs/base/pack.toml`
- Create: `packs/base/data/traits.toml`
- Create: `packs/base/data/npc_traits.toml`
- Create: `packs/base/data/skills.toml`

**Step 1: Write manifest deserialization structs**

```rust
// crates/undone-packs/src/manifest.rs
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct PackManifest {
    pub pack: PackMeta,
    pub content: PackContent,
}

#[derive(Debug, Deserialize)]
pub struct PackMeta {
    pub id: String,
    pub name: String,
    pub version: String,
    pub author: String,
    #[serde(default)]
    pub requires: Vec<String>,
}

#[derive(Debug, Deserialize)]
pub struct PackContent {
    pub traits: String,
    pub npc_traits: String,
    pub skills: String,
    pub scenes_dir: String,
}
```

**Step 2: Write data file structs**

```rust
// crates/undone-packs/src/data.rs
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct TraitFile {
    #[serde(rename = "trait")]
    pub traits: Vec<TraitDef>,
}

#[derive(Debug, Deserialize)]
pub struct TraitDef {
    pub id: String,
    pub name: String,
    pub description: String,
    #[serde(default)]
    pub hidden: bool,
}

#[derive(Debug, Deserialize)]
pub struct NpcTraitFile {
    #[serde(rename = "trait")]
    pub traits: Vec<NpcTraitDef>,
}

#[derive(Debug, Deserialize)]
pub struct NpcTraitDef {
    pub id: String,
    pub name: String,
    pub description: String,
    #[serde(default)]
    pub hidden: bool,
}

#[derive(Debug, Deserialize)]
pub struct SkillFile {
    pub skill: Vec<SkillDef>,
}

#[derive(Debug, Deserialize)]
pub struct SkillDef {
    pub id: String,
    pub name: String,
    pub description: String,
    pub min: i32,
    pub max: i32,
}
```

**Step 3: Write base pack data files**

`packs/base/pack.toml`:
```toml
[pack]
id       = "base"
name     = "Base Game"
version  = "0.1.0"
author   = "Undone"
requires = []

[content]
traits     = "data/traits.toml"
npc_traits = "data/npc_traits.toml"
skills     = "data/skills.toml"
scenes_dir = "scenes/"
```

`packs/base/data/traits.toml`:
```toml
[[trait]]
id          = "SHY"
name        = "Shy"
description = "Avoids eye contact, defers, gets flustered."
hidden      = false

[[trait]]
id          = "POSH"
name        = "Posh"
description = "Notices class signals. Faintly superior."
hidden      = false

[[trait]]
id          = "CUTE"
name        = "Cute"
description = "Genuine enthusiasm, easily delighted."
hidden      = false

[[trait]]
id          = "SULTRY"
name        = "Sultry"
description = "Aware of her effect on people."
hidden      = false

[[trait]]
id          = "BITCHY"
name        = "Bitchy"
description = "Low tolerance for nonsense."
hidden      = false

[[trait]]
id          = "DOWN_TO_EARTH"
name        = "Down to Earth"
description = "Practical, unselfconscious."
hidden      = false

[[trait]]
id          = "REFINED"
name        = "Refined"
description = "Sensitive to vulgarity."
hidden      = false

[[trait]]
id          = "ROMANTIC"
name        = "Romantic"
description = "Takes things slightly more seriously than warranted."
hidden      = false

[[trait]]
id          = "FLIRTY"
name        = "Flirty"
description = "Can't entirely help it."
hidden      = false

[[trait]]
id          = "AMBITIOUS"
name        = "Ambitious"
description = "Goal-focused. Impatient with things that don't advance anything."
hidden      = false

[[trait]]
id          = "OVERACTIVE_IMAGINATION"
name        = "Overactive Imagination"
description = "Takes situations to their logical conclusion."
hidden      = false

[[trait]]
id          = "PLAIN"
name        = "Plain"
description = "A modelling career is out of the question."
hidden      = false

[[trait]]
id          = "BEAUTIFUL"
name        = "Beautiful"
description = "Draws attention wherever she goes."
hidden      = false

[[trait]]
id          = "BLOCK_ROUGH"
name        = "Block Rough Content"
description = "Player preference: no rough or non-consensual content."
hidden      = true

[[trait]]
id          = "LIKES_ROUGH"
name        = "Likes Rough Content"
description = "Player preference: include rough content paths."
hidden      = true

[[trait]]
id          = "ALWAYS_FEMALE"
name        = "Always Female"
description = "PC was never transformed — born female."
hidden      = true

[[trait]]
id          = "NOT_TRANSFORMED"
name        = "Not Transformed"
description = "PC started as a woman (quickstart)."
hidden      = true
```

`packs/base/data/npc_traits.toml`:
```toml
[[trait]]
id          = "CHARMING"
name        = "Charming"
description = "Reads the room well. Can fake warmth convincingly."
hidden      = false

[[trait]]
id          = "SLEAZY"
name        = "Sleazy"
description = "Pushes past comfort faster."
hidden      = false

[[trait]]
id          = "BOASTFUL"
name        = "Boastful"
description = "Redirects everything to himself."
hidden      = false

[[trait]]
id          = "CRUDE"
name        = "Crude"
description = "Less filter between thought and mouth."
hidden      = false

[[trait]]
id          = "TACITURN"
name        = "Taciturn"
description = "Minimal dialogue, communicates through implication."
hidden      = false

[[trait]]
id          = "INTERESTING"
name        = "Interesting"
description = "Very interesting to talk to."
hidden      = false

[[trait]]
id          = "DULL"
name        = "Dull"
description = "Really boring."
hidden      = false

[[trait]]
id          = "HATES_CONDOMS"
name        = "Hates Condoms"
description = "Hates the thought of wearing a condom."
hidden      = false

[[trait]]
id          = "CONSCIENTIOUS"
name        = "Conscientious"
description = "Can usually be trusted to use protection."
hidden      = false

[[trait]]
id          = "WANTS_KIDS"
name        = "Wants Kids"
description = "Wants to have children."
hidden      = false

[[trait]]
id          = "DOESNT_WANT_KIDS"
name        = "Doesn't Want Kids"
description = "Hates the thought of being responsible for children."
hidden      = false

[[trait]]
id          = "VIRILE"
name        = "Virile"
description = "Unprotected sex with him is more likely to have consequences."
hidden      = true

[[trait]]
id          = "INFERTILE"
name        = "Infertile"
description = "Cannot get anyone pregnant."
hidden      = true

[[trait]]
id          = "IMPREGNATOR"
name        = "Impregnator"
description = "Likes getting girls pregnant."
hidden      = true
```

`packs/base/data/skills.toml`:
```toml
[[skill]]
id          = "FITNESS"
name        = "Fitness"
description = "Physical health and capability."
min         = 0
max         = 100

[[skill]]
id          = "CHARM"
name        = "Charm"
description = "Social grace and likability."
min         = 0
max         = 100

[[skill]]
id          = "FASHION"
name        = "Fashion"
description = "Dress sense and style awareness."
min         = 0
max         = 100

[[skill]]
id          = "DANCE"
name        = "Dance"
description = "Ability to dance well."
min         = 0
max         = 100

[[skill]]
id          = "COOKING"
name        = "Cooking"
description = "Ability to prepare food."
min         = 0
max         = 100

[[skill]]
id          = "FEMININITY"
name        = "Femininity"
description = "Adaptation to female identity. Low = still adjusting."
min         = -100
max         = 100

[[skill]]
id          = "ADMIN"
name        = "Paperwork"
description = "Office and administrative competence."
min         = 0
max         = 100

[[skill]]
id          = "MANAGEMENT"
name        = "Management"
description = "Leadership and organisational ability."
min         = 0
max         = 100

[[skill]]
id          = "CHILDCARE"
name        = "Childcare"
description = "Skill at looking after children."
min         = 0
max         = 100
```

**Step 4: Write lib.rs**

```rust
// crates/undone-packs/src/lib.rs
pub mod manifest;
pub mod data;
pub mod registry;   // stub — Task 8

pub use manifest::{PackManifest, PackMeta, PackContent};
pub use data::{TraitDef, NpcTraitDef, SkillDef};
```

**Step 5: Write tests**

```rust
// crates/undone-packs/src/manifest.rs (append)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parses_pack_toml() {
        let src = r#"
            [pack]
            id       = "base"
            name     = "Base Game"
            version  = "0.1.0"
            author   = "Undone"
            requires = []

            [content]
            traits     = "data/traits.toml"
            npc_traits = "data/npc_traits.toml"
            skills     = "data/skills.toml"
            scenes_dir = "scenes/"
        "#;
        let manifest: PackManifest = toml::from_str(src).unwrap();
        assert_eq!(manifest.pack.id, "base");
        assert_eq!(manifest.content.scenes_dir, "scenes/");
    }
}
```

**Step 6: Run tests**

```bash
cargo test -p undone-packs
```

Expected: 1 test passes.

**Step 7: Commit**

```bash
git add crates/undone-packs/ packs/
git commit -m "packs: add manifest/data structs and base pack data files"
```

---

## Task 8: Pack Registry (`undone-packs`)

**Files:**
- Create: `crates/undone-packs/src/registry.rs`
- Modify: `crates/undone-packs/src/lib.rs`

**Step 1: Write PackRegistry**

```rust
// crates/undone-packs/src/registry.rs
use std::collections::HashMap;
use lasso::{Rodeo, Spur};
use undone_domain::{TraitId, NpcTraitId, SkillId, PersonalityId, StatId};
use crate::data::{TraitDef, NpcTraitDef, SkillDef};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum RegistryError {
    #[error("unknown trait id: {0}")]
    UnknownTrait(String),
    #[error("unknown npc trait id: {0}")]
    UnknownNpcTrait(String),
    #[error("unknown skill id: {0}")]
    UnknownSkill(String),
}

/// Central registry for all content-level IDs across all loaded packs.
/// Owns the string interner — all TraitId/SkillId/etc. are valid only
/// within the context of the registry that created them.
pub struct PackRegistry {
    rodeo: Rodeo,
    pub trait_defs: HashMap<TraitId, TraitDef>,
    pub npc_trait_defs: HashMap<NpcTraitId, NpcTraitDef>,
    pub skill_defs: HashMap<SkillId, SkillDef>,
}

impl PackRegistry {
    pub fn new() -> Self {
        Self {
            rodeo: Rodeo::new(),
            trait_defs: HashMap::new(),
            npc_trait_defs: HashMap::new(),
            skill_defs: HashMap::new(),
        }
    }

    /// Intern a string and return a raw Spur. Used internally.
    fn intern(&mut self, s: &str) -> Spur {
        self.rodeo.get_or_intern(s)
    }

    /// Register player traits from a pack data file.
    pub fn register_traits(&mut self, defs: Vec<TraitDef>) {
        for def in defs {
            let spur = self.intern(&def.id);
            self.trait_defs.insert(TraitId(spur), def);
        }
    }

    /// Register NPC traits from a pack data file.
    pub fn register_npc_traits(&mut self, defs: Vec<NpcTraitDef>) {
        for def in defs {
            let spur = self.intern(&def.id);
            self.npc_trait_defs.insert(NpcTraitId(spur), def);
        }
    }

    /// Register skills from a pack data file.
    pub fn register_skills(&mut self, defs: Vec<SkillDef>) {
        for def in defs {
            let spur = self.intern(&def.id);
            self.skill_defs.insert(SkillId(spur), def);
        }
    }

    /// Resolve a string to a TraitId. Errors if the id is unknown.
    /// Call this at scene load time to validate condition expressions.
    pub fn resolve_trait(&self, id: &str) -> Result<TraitId, RegistryError> {
        self.rodeo
            .get(id)
            .and_then(|s| {
                let tid = TraitId(s);
                self.trait_defs.contains_key(&tid).then_some(tid)
            })
            .ok_or_else(|| RegistryError::UnknownTrait(id.to_string()))
    }

    /// Resolve a string to an NpcTraitId.
    pub fn resolve_npc_trait(&self, id: &str) -> Result<NpcTraitId, RegistryError> {
        self.rodeo
            .get(id)
            .and_then(|s| {
                let tid = NpcTraitId(s);
                self.npc_trait_defs.contains_key(&tid).then_some(tid)
            })
            .ok_or_else(|| RegistryError::UnknownNpcTrait(id.to_string()))
    }

    /// Resolve a string to a SkillId.
    pub fn resolve_skill(&self, id: &str) -> Result<SkillId, RegistryError> {
        self.rodeo
            .get(id)
            .and_then(|s| {
                let sid = SkillId(s);
                self.skill_defs.contains_key(&sid).then_some(sid)
            })
            .ok_or_else(|| RegistryError::UnknownSkill(id.to_string()))
    }

    /// Intern a stat name (stat names don't need definitions, just interning).
    pub fn intern_stat(&mut self, id: &str) -> StatId {
        StatId(self.intern(id))
    }
}

impl Default for PackRegistry {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::data::TraitDef;

    fn make_registry() -> PackRegistry {
        let mut reg = PackRegistry::new();
        reg.register_traits(vec![
            TraitDef {
                id: "SHY".into(),
                name: "Shy".into(),
                description: "...".into(),
                hidden: false,
            },
            TraitDef {
                id: "POSH".into(),
                name: "Posh".into(),
                description: "...".into(),
                hidden: false,
            },
        ]);
        reg
    }

    #[test]
    fn resolves_known_trait() {
        let reg = make_registry();
        assert!(reg.resolve_trait("SHY").is_ok());
        assert!(reg.resolve_trait("POSH").is_ok());
    }

    #[test]
    fn errors_on_unknown_trait() {
        let reg = make_registry();
        assert!(reg.resolve_trait("TYPO").is_err());
    }

    #[test]
    fn same_id_string_resolves_to_same_spur() {
        let reg = make_registry();
        let a = reg.resolve_trait("SHY").unwrap();
        let b = reg.resolve_trait("SHY").unwrap();
        assert_eq!(a, b);
    }
}
```

**Step 2: Export from lib.rs**

Add to `crates/undone-packs/src/lib.rs`:
```rust
pub mod registry;
pub use registry::{PackRegistry, RegistryError};
```

**Step 3: Run tests**

```bash
cargo test -p undone-packs
```

Expected: 3 registry tests + 1 manifest test = 4 pass.

**Step 4: Commit**

```bash
git add crates/undone-packs/
git commit -m "packs: add PackRegistry with lasso string interning and load-time validation"
```

---

## Task 9: Expression Lexer (`undone-expr`)

**Files:**
- Create: `crates/undone-expr/src/lib.rs`
- Create: `crates/undone-expr/src/lexer.rs`

**Step 1: Write Token and Lexer**

```rust
// crates/undone-expr/src/lexer.rs
use thiserror::Error;

#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    // Identifiers and literals
    Ident(String),
    StringLit(String),
    IntLit(i64),
    BoolLit(bool),

    // Punctuation
    Dot,
    Comma,
    LParen,
    RParen,

    // Boolean operators
    Bang,
    And,
    Or,

    // Comparison operators
    Eq,
    Ne,
    Lt,
    Gt,
    Le,
    Ge,

    Eof,
}

#[derive(Debug, Error, Clone)]
pub enum LexError {
    #[error("unexpected character '{0}' at position {1}")]
    UnexpectedChar(char, usize),
    #[error("unterminated string at position {0}")]
    UnterminatedString(usize),
}

pub fn tokenize(src: &str) -> Result<Vec<Token>, LexError> {
    let mut tokens = Vec::new();
    let chars: Vec<char> = src.chars().collect();
    let mut i = 0;

    while i < chars.len() {
        match chars[i] {
            ' ' | '\t' | '\n' | '\r' => { i += 1; }
            '.' => { tokens.push(Token::Dot);    i += 1; }
            ',' => { tokens.push(Token::Comma);  i += 1; }
            '(' => { tokens.push(Token::LParen); i += 1; }
            ')' => { tokens.push(Token::RParen); i += 1; }
            '!' => {
                if i + 1 < chars.len() && chars[i + 1] == '=' {
                    tokens.push(Token::Ne); i += 2;
                } else {
                    tokens.push(Token::Bang); i += 1;
                }
            }
            '&' if i + 1 < chars.len() && chars[i + 1] == '&' => {
                tokens.push(Token::And); i += 2;
            }
            '|' if i + 1 < chars.len() && chars[i + 1] == '|' => {
                tokens.push(Token::Or); i += 2;
            }
            '=' if i + 1 < chars.len() && chars[i + 1] == '=' => {
                tokens.push(Token::Eq); i += 2;
            }
            '<' => {
                if i + 1 < chars.len() && chars[i + 1] == '=' {
                    tokens.push(Token::Le); i += 2;
                } else {
                    tokens.push(Token::Lt); i += 1;
                }
            }
            '>' => {
                if i + 1 < chars.len() && chars[i + 1] == '=' {
                    tokens.push(Token::Ge); i += 2;
                } else {
                    tokens.push(Token::Gt); i += 1;
                }
            }
            '"' | '\'' => {
                let quote = chars[i];
                let start = i + 1;
                i += 1;
                while i < chars.len() && chars[i] != quote {
                    i += 1;
                }
                if i >= chars.len() {
                    return Err(LexError::UnterminatedString(start));
                }
                let s: String = chars[start..i].iter().collect();
                tokens.push(Token::StringLit(s));
                i += 1; // closing quote
            }
            c if c.is_ascii_digit() => {
                let start = i;
                while i < chars.len() && chars[i].is_ascii_digit() {
                    i += 1;
                }
                let n: String = chars[start..i].iter().collect();
                tokens.push(Token::IntLit(n.parse().unwrap()));
            }
            c if c.is_alphabetic() || c == '_' => {
                let start = i;
                while i < chars.len() && (chars[i].is_alphanumeric() || chars[i] == '_') {
                    i += 1;
                }
                let s: String = chars[start..i].iter().collect();
                let tok = match s.as_str() {
                    "true"  => Token::BoolLit(true),
                    "false" => Token::BoolLit(false),
                    _       => Token::Ident(s),
                };
                tokens.push(tok);
            }
            c => return Err(LexError::UnexpectedChar(c, i)),
        }
    }

    tokens.push(Token::Eof);
    Ok(tokens)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn tokenizes_method_call() {
        let toks = tokenize("w.hasTrait(\"SHY\")").unwrap();
        assert_eq!(toks[0], Token::Ident("w".into()));
        assert_eq!(toks[1], Token::Dot);
        assert_eq!(toks[2], Token::Ident("hasTrait".into()));
        assert_eq!(toks[3], Token::LParen);
        assert_eq!(toks[4], Token::StringLit("SHY".into()));
        assert_eq!(toks[5], Token::RParen);
    }

    #[test]
    fn tokenizes_boolean_operators() {
        let toks = tokenize("!a && b || c").unwrap();
        assert_eq!(toks[0], Token::Bang);
        assert_eq!(toks[2], Token::And);
        assert_eq!(toks[4], Token::Or);
    }

    #[test]
    fn tokenizes_comparison() {
        let toks = tokenize("x >= 20").unwrap();
        assert_eq!(toks[1], Token::Ge);
        assert_eq!(toks[2], Token::IntLit(20));
    }

    #[test]
    fn single_quote_strings() {
        let toks = tokenize("w.hasTrait('SHY')").unwrap();
        assert_eq!(toks[4], Token::StringLit("SHY".into()));
    }

    #[test]
    fn bool_literals() {
        let toks = tokenize("true && false").unwrap();
        assert_eq!(toks[0], Token::BoolLit(true));
        assert_eq!(toks[2], Token::BoolLit(false));
    }
}
```

**Step 2: Write lib.rs**

```rust
// crates/undone-expr/src/lib.rs
pub mod lexer;
pub mod parser;   // stub — Task 10
pub mod eval;     // stub — Task 11
```

Create stubs:
```bash
touch crates/undone-expr/src/parser.rs
touch crates/undone-expr/src/eval.rs
```

**Step 3: Run tests**

```bash
cargo test -p undone-expr
```

Expected: 5 lexer tests pass.

**Step 4: Commit**

```bash
git add crates/undone-expr/
git commit -m "expr: add lexer with full token set and tests"
```

---

## Task 10: Expression Parser (`undone-expr`)

**Files:**
- Modify: `crates/undone-expr/src/parser.rs`

**Step 1: Write AST and recursive descent parser**

```rust
// crates/undone-expr/src/parser.rs
use crate::lexer::{Token, tokenize, LexError};
use thiserror::Error;

#[derive(Debug, Clone, PartialEq)]
pub enum Receiver {
    Player,      // w
    MaleNpc,     // m
    FemaleNpc,   // f
    Scene,       // scene
    GameData,    // gd
}

#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    Str(String),
    Int(i64),
    Bool(bool),
}

#[derive(Debug, Clone, PartialEq)]
pub struct Call {
    pub receiver: Receiver,
    pub method: String,
    pub args: Vec<Value>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Expr {
    Call(Call),
    Not(Box<Expr>),
    And(Box<Expr>, Box<Expr>),
    Or(Box<Expr>, Box<Expr>),
    Eq(Box<Expr>, Box<Expr>),
    Ne(Box<Expr>, Box<Expr>),
    Lt(Box<Expr>, Box<Expr>),
    Gt(Box<Expr>, Box<Expr>),
    Le(Box<Expr>, Box<Expr>),
    Ge(Box<Expr>, Box<Expr>),
    Lit(Value),
}

#[derive(Debug, Error)]
pub enum ParseError {
    #[error("lex error: {0}")]
    Lex(#[from] LexError),
    #[error("unexpected token {0:?} at position {1}")]
    Unexpected(Token, usize),
    #[error("unknown receiver '{0}'")]
    UnknownReceiver(String),
    #[error("expected ')' to close argument list")]
    UnclosedArgs,
    #[error("empty expression")]
    Empty,
}

struct Parser {
    tokens: Vec<Token>,
    pos: usize,
}

impl Parser {
    fn new(tokens: Vec<Token>) -> Self {
        Self { tokens, pos: 0 }
    }

    fn peek(&self) -> &Token {
        &self.tokens[self.pos]
    }

    fn advance(&mut self) -> &Token {
        let t = &self.tokens[self.pos];
        if self.pos + 1 < self.tokens.len() {
            self.pos += 1;
        }
        t
    }

    fn expect(&mut self, expected: &Token) -> Result<(), ParseError> {
        if self.peek() == expected {
            self.advance();
            Ok(())
        } else {
            Err(ParseError::Unexpected(self.peek().clone(), self.pos))
        }
    }

    fn parse_expr(&mut self) -> Result<Expr, ParseError> {
        self.parse_or()
    }

    fn parse_or(&mut self) -> Result<Expr, ParseError> {
        let mut left = self.parse_and()?;
        while self.peek() == &Token::Or {
            self.advance();
            let right = self.parse_and()?;
            left = Expr::Or(Box::new(left), Box::new(right));
        }
        Ok(left)
    }

    fn parse_and(&mut self) -> Result<Expr, ParseError> {
        let mut left = self.parse_not()?;
        while self.peek() == &Token::And {
            self.advance();
            let right = self.parse_not()?;
            left = Expr::And(Box::new(left), Box::new(right));
        }
        Ok(left)
    }

    fn parse_not(&mut self) -> Result<Expr, ParseError> {
        if self.peek() == &Token::Bang {
            self.advance();
            let inner = self.parse_not()?;
            return Ok(Expr::Not(Box::new(inner)));
        }
        self.parse_compare()
    }

    fn parse_compare(&mut self) -> Result<Expr, ParseError> {
        let left = self.parse_primary()?;
        let op = match self.peek() {
            Token::Eq => { self.advance(); Some("==") }
            Token::Ne => { self.advance(); Some("!=") }
            Token::Lt => { self.advance(); Some("<")  }
            Token::Gt => { self.advance(); Some(">")  }
            Token::Le => { self.advance(); Some("<=") }
            Token::Ge => { self.advance(); Some(">=") }
            _ => None,
        };
        if let Some(op) = op {
            let right = self.parse_primary()?;
            Ok(match op {
                "==" => Expr::Eq(Box::new(left), Box::new(right)),
                "!=" => Expr::Ne(Box::new(left), Box::new(right)),
                "<"  => Expr::Lt(Box::new(left), Box::new(right)),
                ">"  => Expr::Gt(Box::new(left), Box::new(right)),
                "<=" => Expr::Le(Box::new(left), Box::new(right)),
                ">=" => Expr::Ge(Box::new(left), Box::new(right)),
                _    => unreachable!(),
            })
        } else {
            Ok(left)
        }
    }

    fn parse_primary(&mut self) -> Result<Expr, ParseError> {
        match self.peek().clone() {
            Token::StringLit(s) => { self.advance(); Ok(Expr::Lit(Value::Str(s))) }
            Token::IntLit(n)    => { self.advance(); Ok(Expr::Lit(Value::Int(n))) }
            Token::BoolLit(b)   => { self.advance(); Ok(Expr::Lit(Value::Bool(b))) }
            Token::Ident(name)  => {
                self.advance();
                // Must be receiver.method(args)
                self.expect(&Token::Dot)?;
                let receiver = match name.as_str() {
                    "w"     => Receiver::Player,
                    "m"     => Receiver::MaleNpc,
                    "f"     => Receiver::FemaleNpc,
                    "scene" => Receiver::Scene,
                    "gd"    => Receiver::GameData,
                    other   => return Err(ParseError::UnknownReceiver(other.to_string())),
                };
                let method = if let Token::Ident(m) = self.advance().clone() {
                    m
                } else {
                    return Err(ParseError::Unexpected(self.peek().clone(), self.pos));
                };
                self.expect(&Token::LParen)?;
                let mut args = Vec::new();
                while self.peek() != &Token::RParen {
                    if !args.is_empty() {
                        self.expect(&Token::Comma)?;
                    }
                    let arg = match self.advance().clone() {
                        Token::StringLit(s) => Value::Str(s),
                        Token::IntLit(n)    => Value::Int(n),
                        Token::BoolLit(b)   => Value::Bool(b),
                        Token::Eof          => return Err(ParseError::UnclosedArgs),
                        other               => return Err(ParseError::Unexpected(other, self.pos)),
                    };
                    args.push(arg);
                }
                self.expect(&Token::RParen)?;
                Ok(Expr::Call(Call { receiver, method, args }))
            }
            Token::LParen => {
                self.advance();
                let inner = self.parse_expr()?;
                self.expect(&Token::RParen)?;
                Ok(inner)
            }
            other => Err(ParseError::Unexpected(other, self.pos)),
        }
    }
}

pub fn parse(src: &str) -> Result<Expr, ParseError> {
    let tokens = tokenize(src)?;
    if tokens == vec![Token::Eof] {
        return Err(ParseError::Empty);
    }
    let mut parser = Parser::new(tokens);
    parser.parse_expr()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parses_simple_method_call() {
        let expr = parse("w.hasTrait(\"SHY\")").unwrap();
        assert_eq!(expr, Expr::Call(Call {
            receiver: Receiver::Player,
            method: "hasTrait".into(),
            args: vec![Value::Str("SHY".into())],
        }));
    }

    #[test]
    fn parses_negation() {
        let expr = parse("!w.hasTrait('POSH')").unwrap();
        assert!(matches!(expr, Expr::Not(_)));
    }

    #[test]
    fn parses_and() {
        let expr = parse("w.hasTrait('SHY') && !m.isPartner()").unwrap();
        assert!(matches!(expr, Expr::And(_, _)));
    }

    #[test]
    fn parses_comparison() {
        let expr = parse("w.getSkill('FITNESS') > 20").unwrap();
        assert!(matches!(expr, Expr::Gt(_, _)));
    }

    #[test]
    fn parses_complex_condition() {
        let src = "m.hasTrait('SLEAZY') && !w.hasTrait('BLOCK_ROUGH') || gd.week > 2";
        assert!(parse(src).is_ok());
    }

    #[test]
    fn errors_on_unknown_receiver() {
        assert!(parse("x.something()").is_err());
    }

    #[test]
    fn errors_on_empty() {
        assert!(parse("").is_err());
    }
}
```

**Step 3: Run tests**

```bash
cargo test -p undone-expr
```

Expected: 5 lexer tests + 7 parser tests = 12 pass.

**Step 4: Commit**

```bash
git add crates/undone-expr/
git commit -m "expr: add recursive descent parser producing typed AST"
```

---

## Task 11: Expression Evaluator (`undone-expr`)

**Files:**
- Modify: `crates/undone-expr/src/eval.rs`
- Modify: `crates/undone-expr/src/lib.rs`

**Step 1: Write SceneCtx and evaluator**

```rust
// crates/undone-expr/src/eval.rs
use std::collections::{HashMap, HashSet};
use thiserror::Error;
use undone_domain::{MaleNpcKey, FemaleNpcKey};
use undone_world::World;
use crate::parser::{Expr, Call, Receiver, Value};

/// Per-scene mutable state passed to the evaluator.
/// Lives only for the duration of a scene run.
pub struct SceneCtx {
    pub active_male: Option<MaleNpcKey>,
    pub active_female: Option<FemaleNpcKey>,
    pub scene_flags: HashSet<String>,
    pub weighted_map: HashMap<String, i32>,
}

impl SceneCtx {
    pub fn new() -> Self {
        Self {
            active_male: None,
            active_female: None,
            scene_flags: HashSet::new(),
            weighted_map: HashMap::new(),
        }
    }

    pub fn has_flag(&self, flag: &str) -> bool {
        self.scene_flags.contains(flag)
    }

    pub fn set_flag(&mut self, flag: impl Into<String>) {
        self.scene_flags.insert(flag.into());
    }
}

impl Default for SceneCtx {
    fn default() -> Self { Self::new() }
}

#[derive(Debug, Error)]
pub enum EvalError {
    #[error("no active male NPC in scene context")]
    NoActiveMaleNpc,
    #[error("no active female NPC in scene context")]
    NoActiveFemaleNpc,
    #[error("unknown method '{receiver}.{method}'")]
    UnknownMethod { receiver: String, method: String },
    #[error("wrong argument type for '{0}'")]
    BadArg(String),
    #[error("NPC key not found in world")]
    NpcNotFound,
}

/// Evaluate a parsed expression to bool.
pub fn eval(expr: &Expr, world: &World, ctx: &SceneCtx) -> Result<bool, EvalError> {
    match expr {
        Expr::Lit(Value::Bool(b)) => Ok(*b),
        Expr::Lit(_) => Ok(true), // non-bool literals as conditions are truthy

        Expr::Not(inner) => Ok(!eval(inner, world, ctx)?),

        Expr::And(l, r) => Ok(eval(l, world, ctx)? && eval(r, world, ctx)?),
        Expr::Or(l, r)  => Ok(eval(l, world, ctx)? || eval(r, world, ctx)?),

        Expr::Eq(l, r) => {
            let lv = eval_to_value(l, world, ctx)?;
            let rv = eval_to_value(r, world, ctx)?;
            Ok(lv == rv)
        }
        Expr::Ne(l, r) => {
            let lv = eval_to_value(l, world, ctx)?;
            let rv = eval_to_value(r, world, ctx)?;
            Ok(lv != rv)
        }
        Expr::Lt(l, r) => int_compare(l, r, world, ctx, |a, b| a < b),
        Expr::Gt(l, r) => int_compare(l, r, world, ctx, |a, b| a > b),
        Expr::Le(l, r) => int_compare(l, r, world, ctx, |a, b| a <= b),
        Expr::Ge(l, r) => int_compare(l, r, world, ctx, |a, b| a >= b),

        Expr::Call(call) => eval_call_bool(call, world, ctx),
    }
}

fn int_compare(
    l: &Expr, r: &Expr,
    world: &World, ctx: &SceneCtx,
    cmp: impl Fn(i64, i64) -> bool,
) -> Result<bool, EvalError> {
    let lv = eval_to_int(l, world, ctx)?;
    let rv = eval_to_int(r, world, ctx)?;
    Ok(cmp(lv, rv))
}

/// Evaluate an expression to a generic Value for comparison.
fn eval_to_value(expr: &Expr, world: &World, ctx: &SceneCtx) -> Result<EvalValue, EvalError> {
    match expr {
        Expr::Lit(v) => Ok(match v {
            Value::Str(s)  => EvalValue::Str(s.clone()),
            Value::Int(n)  => EvalValue::Int(*n),
            Value::Bool(b) => EvalValue::Bool(*b),
        }),
        Expr::Call(call) => {
            // Try to eval as int, then bool
            if let Ok(n) = eval_call_int(call, world, ctx) {
                return Ok(EvalValue::Int(n));
            }
            let b = eval_call_bool(call, world, ctx)?;
            Ok(EvalValue::Bool(b))
        }
        other => {
            let b = eval(other, world, ctx)?;
            Ok(EvalValue::Bool(b))
        }
    }
}

fn eval_to_int(expr: &Expr, world: &World, ctx: &SceneCtx) -> Result<i64, EvalError> {
    match expr {
        Expr::Lit(Value::Int(n)) => Ok(*n),
        Expr::Call(call) => eval_call_int(call, world, ctx),
        _ => Err(EvalError::BadArg("expected integer".into())),
    }
}

#[derive(Debug, PartialEq)]
enum EvalValue {
    Str(String),
    Int(i64),
    Bool(bool),
}

/// Evaluate a method call that returns bool.
fn eval_call_bool(call: &Call, world: &World, ctx: &SceneCtx) -> Result<bool, EvalError> {
    let str_arg = |i: usize| -> Result<&str, EvalError> {
        match call.args.get(i) {
            Some(Value::Str(s)) => Ok(s.as_str()),
            _ => Err(EvalError::BadArg(call.method.clone())),
        }
    };

    match call.receiver {
        Receiver::Player => match call.method.as_str() {
            "hasTrait"      => Ok(world.player.traits.iter().any(|t| {
                // We compare by interned spur via registry — for now compare
                // by looking up in rodeo. This will be wired to PackRegistry
                // in integration. For unit tests, always false on empty traits.
                false // TODO: wire to registry in scene engine
            })),
            "isVirgin"      => Ok(world.player.virgin),
            "isAnalVirgin"  => Ok(world.player.anal_virgin),
            "isDrunk"       => Ok(world.player.is_drunk()),
            "isVeryDrunk"   => Ok(world.player.is_very_drunk()),
            "isMaxDrunk"    => Ok(world.player.is_max_drunk()),
            "isSingle"      => Ok(world.player.partner.is_none()),
            "isOnPill"      => Ok(world.player.on_pill),
            "isPregnant"    => Ok(world.player.pregnancy.is_some()),
            "alwaysFemale"  => Ok(world.player.always_female),
            "hasStuff"      => Ok(false), // TODO: wire to StuffId
            _ => Err(EvalError::UnknownMethod {
                receiver: "w".into(),
                method: call.method.clone(),
            }),
        },

        Receiver::MaleNpc => {
            let key = ctx.active_male.ok_or(EvalError::NoActiveMaleNpc)?;
            let npc = world.male_npc(key).ok_or(EvalError::NpcNotFound)?;
            match call.method.as_str() {
                "isPartner"          => Ok(npc.core.is_partner()),
                "isFriend"           => Ok(npc.core.is_friend()),
                "isCohabiting"       => Ok(npc.core.is_cohabiting()),
                "isContactable"      => Ok(npc.core.contactable),
                "hadOrgasm"          => Ok(npc.had_orgasm),
                "hasTrait"           => Ok(false), // TODO: wire to registry
                "isNpcAttractionOk"  => Ok(npc.core.npc_attraction >= undone_domain::AttractionLevel::Ok),
                "isNpcAttractionLust"=> Ok(npc.core.npc_attraction == undone_domain::AttractionLevel::Lust),
                "isWAttractionOk"    => Ok(npc.core.pc_attraction >= undone_domain::AttractionLevel::Ok),
                "isNpcLoveCrush"     => Ok(npc.core.npc_love >= undone_domain::LoveLevel::Crush),
                "isNpcLoveSome"      => Ok(npc.core.npc_love >= undone_domain::LoveLevel::Some),
                "isWLoveCrush"       => Ok(npc.core.pc_love >= undone_domain::LoveLevel::Crush),
                _ => Err(EvalError::UnknownMethod {
                    receiver: "m".into(),
                    method: call.method.clone(),
                }),
            }
        }

        Receiver::Scene => match call.method.as_str() {
            "hasFlag" => {
                let flag = str_arg(0)?;
                Ok(ctx.has_flag(flag))
            }
            _ => Err(EvalError::UnknownMethod {
                receiver: "scene".into(),
                method: call.method.clone(),
            }),
        },

        Receiver::GameData => match call.method.as_str() {
            "hasGameFlag" => {
                let flag = str_arg(0)?;
                Ok(world.game_data.has_flag(flag))
            }
            _ => Err(EvalError::UnknownMethod {
                receiver: "gd".into(),
                method: call.method.clone(),
            }),
        },

        Receiver::FemaleNpc => {
            let key = ctx.active_female.ok_or(EvalError::NoActiveFemaleNpc)?;
            let npc = world.female_npc(key).ok_or(EvalError::NpcNotFound)?;
            match call.method.as_str() {
                "isPartner"   => Ok(npc.core.is_partner()),
                "isFriend"    => Ok(npc.core.is_friend()),
                "isPregnant"  => Ok(npc.pregnancy.is_some()),
                "isVirgin"    => Ok(npc.virgin),
                _ => Err(EvalError::UnknownMethod {
                    receiver: "f".into(),
                    method: call.method.clone(),
                }),
            }
        }
    }
}

/// Evaluate a method call that returns an integer (e.g. getSkill, getStat, week).
fn eval_call_int(call: &Call, world: &World, _ctx: &SceneCtx) -> Result<i64, EvalError> {
    match call.receiver {
        Receiver::Player => match call.method.as_str() {
            "getMoney"  => Ok(world.player.money as i64),
            "getStress" => Ok(world.player.stress as i64),
            "getSkill"  => Ok(0), // TODO: wire to SkillId via registry
            _ => Err(EvalError::UnknownMethod {
                receiver: "w".into(),
                method: call.method.clone(),
            }),
        },
        Receiver::GameData => match call.method.as_str() {
            "week"    => Ok(world.game_data.week as i64),
            "getStat" => Ok(0), // TODO: wire to StatId via registry
            _ => Err(EvalError::UnknownMethod {
                receiver: "gd".into(),
                method: call.method.clone(),
            }),
        },
        _ => Err(EvalError::UnknownMethod {
            receiver: format!("{:?}", call.receiver),
            method: call.method.clone(),
        }),
    }
}
```

> **Note on TODOs:** The `hasTrait` and `getSkill` evaluations are stubbed here
> because they require the `PackRegistry` interner to resolve strings to IDs.
> The scene engine (`undone-scene`) wires these up in Task 12 by passing the
> registry into eval. The TODO comments mark exactly where to extend.

**Step 2: Update lib.rs**

```rust
// crates/undone-expr/src/lib.rs
pub mod lexer;
pub mod parser;
pub mod eval;

pub use parser::{Expr, Call, Receiver, Value, ParseError, parse};
pub use eval::{SceneCtx, EvalError, eval};
```

**Step 3: Write integration tests**

```rust
// append to crates/undone-expr/src/eval.rs
#[cfg(test)]
mod tests {
    use super::*;
    use undone_world::World;
    use undone_domain::*;
    use std::collections::{HashMap, HashSet};
    use slotmap::SlotMap;
    use crate::parser::parse;
    use undone_world::GameData;

    fn make_world() -> World {
        World {
            player: undone_domain::Player {
                name: "Eva".into(),
                age: Age::LateTeen,
                race: "east_asian".into(),
                figure: PlayerFigure::Slim,
                breasts: BreastSize::Large,
                eye_colour: "brown".into(),
                hair_colour: "dark".into(),
                traits: HashSet::new(),
                skills: HashMap::new(),
                money: 500,
                stress: 10,
                anxiety: 0,
                arousal: ArousalLevel::Comfort,
                alcohol: AlcoholLevel::Sober,
                partner: None,
                friends: vec![],
                virgin: true,
                anal_virgin: true,
                lesbian_virgin: true,
                on_pill: false,
                pregnancy: None,
                stuff: HashSet::new(),
                custom_flags: HashMap::new(),
                custom_ints: HashMap::new(),
                always_female: false,
                femininity: 10,
            },
            male_npcs: SlotMap::with_key(),
            female_npcs: SlotMap::with_key(),
            game_data: GameData::default(),
        }
    }

    #[test]
    fn eval_bool_literal_true() {
        let world = make_world();
        let ctx = SceneCtx::new();
        let expr = parse("true").unwrap();
        assert!(eval(&expr, &world, &ctx).unwrap());
    }

    #[test]
    fn eval_is_virgin() {
        let world = make_world();
        let ctx = SceneCtx::new();
        let expr = parse("w.isVirgin()").unwrap();
        assert!(eval(&expr, &world, &ctx).unwrap());
    }

    #[test]
    fn eval_is_not_drunk() {
        let world = make_world();
        let ctx = SceneCtx::new();
        let expr = parse("!w.isDrunk()").unwrap();
        assert!(eval(&expr, &world, &ctx).unwrap());
    }

    #[test]
    fn eval_game_flag_absent() {
        let world = make_world();
        let ctx = SceneCtx::new();
        let expr = parse("gd.hasGameFlag('SOME_FLAG')").unwrap();
        assert!(!eval(&expr, &world, &ctx).unwrap());
    }

    #[test]
    fn eval_game_flag_present() {
        let mut world = make_world();
        world.game_data.set_flag("SOME_FLAG");
        let ctx = SceneCtx::new();
        let expr = parse("gd.hasGameFlag('SOME_FLAG')").unwrap();
        assert!(eval(&expr, &world, &ctx).unwrap());
    }

    #[test]
    fn eval_money_comparison() {
        let world = make_world(); // money = 500
        let ctx = SceneCtx::new();
        let expr = parse("w.getMoney() > 100").unwrap();
        assert!(eval(&expr, &world, &ctx).unwrap());
    }

    #[test]
    fn eval_scene_flag() {
        let world = make_world();
        let mut ctx = SceneCtx::new();
        ctx.set_flag("offered_umbrella");
        let expr = parse("scene.hasFlag('offered_umbrella')").unwrap();
        assert!(eval(&expr, &world, &ctx).unwrap());
    }
}
```

**Step 4: Run tests**

```bash
cargo test -p undone-expr
```

Expected: 5 lexer + 7 parser + 7 eval tests = 19 pass.

**Step 5: Commit**

```bash
git add crates/undone-expr/
git commit -m "expr: add evaluator with SceneCtx, bool/int dispatch, game flag tests"
```

---

## Task 12: Minimal eframe Window (`undone-ui`)

**Files:**
- Modify: `crates/undone-ui/src/lib.rs`
- Modify: `src/main.rs`

**Step 1: Write the app shell**

```rust
// crates/undone-ui/src/lib.rs
use eframe::egui;

pub struct UndoneApp {
    story_text: String,
}

impl UndoneApp {
    pub fn new(_cc: &eframe::CreationContext<'_>) -> Self {
        Self {
            story_text: "Undone is starting up.\n\nNo scene loaded yet.".into(),
        }
    }
}

impl eframe::App for UndoneApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        egui::CentralPanel::default().show(ctx, |ui| {
            ui.vertical(|ui| {
                // Story text — top panel
                egui::ScrollArea::vertical()
                    .max_height(ui.available_height() - 80.0)
                    .show(ui, |ui| {
                        ui.label(egui::RichText::new(&self.story_text).size(16.0));
                    });

                ui.separator();

                // Action buttons — bottom row
                ui.horizontal(|ui| {
                    if ui.button("[ No actions available ]").clicked() {
                        // placeholder
                    }
                });
            });
        });
    }
}
```

**Step 2: Wire in main.rs**

```rust
// src/main.rs
use anyhow::Result;
use undone_ui::UndoneApp;

fn main() -> Result<()> {
    tracing_subscriber::fmt::init();

    let options = eframe::NativeOptions {
        viewport: eframe::egui::ViewportBuilder::default()
            .with_title("Undone")
            .with_inner_size([900.0, 600.0]),
        ..Default::default()
    };

    eframe::run_native(
        "Undone",
        options,
        Box::new(|cc| Ok(Box::new(UndoneApp::new(cc)))),
    )
    .map_err(|e| anyhow::anyhow!("eframe error: {e}"))
}
```

**Step 3: Build and run**

```bash
cargo run
```

Expected: a 900×600 window appears titled "Undone" with placeholder story text
and a disabled button row. Close it to exit.

**Step 4: Commit**

```bash
git add crates/undone-ui/ src/
git commit -m "ui: add minimal eframe window shell with story text placeholder"
```

---

## Task 13: Final Verification

**Step 1: Run all tests**

```bash
cargo test --workspace
```

Expected: all tests pass across all crates. Note the exact count.

**Step 2: Run clippy**

```bash
cargo clippy --workspace -- -D warnings
```

Fix any warnings before proceeding. Common Rust clippy notes:
- Unused variables: prefix with `_`
- `if let` instead of `match` for single-arm matches

**Step 3: Build release**

```bash
cargo build --release
```

Expected: clean build, binary at `target/release/undone.exe`.

**Step 4: Final commit**

```bash
git add .
git commit -m "scaffold: complete — all crates compile, tests pass, window runs"
```

---

## What's Next (Future Sessions)

This scaffold gives the next session a clean foundation. Subsequent plans will cover:

1. **Scene loader** — TOML → `SceneDefinition` structs, expression validation at load, Effect enum deserialization
2. **Effect executor** — apply `Effect` variants to `&mut World`
3. **Scene execution engine** — the full action loop with minijinja prose rendering
4. **Pack loader** — walk `packs/` directory, load manifests, wire registry into evaluator
5. **Scheduler** — weekly timeslot event selection
6. **Save/load** — `World` → JSON and back
7. **UI iteration** — three-panel layout, rich text, character info panel, action routing

---

*Implementation plan: 2026-02-21. Based on design doc: `docs/plans/2026-02-21-engine-design.md`*
