# UI — floem Migration & Layout Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace the egui/eframe placeholder with a floem-based UI that implements the two-panel game layout designed in `docs/plans/2026-02-22-design-decisions.md` § 4.

**Architecture:** `GameState` (held in `Rc<RefCell<...>>`) owns `SceneEngine + World + PackRegistry`. floem `RwSignal`s carry display-ready snapshots to the view tree. Button click handlers mutate `GameState`, drain engine events, and push updated signals.

**Tech Stack:** floem (lapce-ide/floem on crates.io), Rust workspace. No egui/eframe after this session.

**Design anchor (§ 4 of design-decisions.md):**
```
┌────────────────────────────────────┬───────────────────┐
│  STORY TEXT                        │  PC STATS         │
│  (serif, ~65–70 chars wide)        │  (always visible) │
│                                    ├───────────────────┤
│  [Mechanical change reports]       │  NPC PANEL        │
│                                    │  (only if in scene)│
├────────────────────────────────────┴───────────────────┤
│  [ Action A ]  [ Action B ]  [ Action C ]              │
└────────────────────────────────────────────────────────┘
```

Typography: 16–18px body, serif font, 1.45–1.6× line height (explicit in floem).

---

## Pre-flight: check floem version

Before starting any task, run:
```bash
cargo search floem | head -5
```
Use the latest stable version from crates.io. At the time of writing this plan the expected version is in the `0.1.x`–`0.2.x` range. **Check floem's README/examples for the current API** — the signal and view APIs have evolved. Adjust code snippets as needed based on current docs.

---

## Task 1: Switch dependencies — egui/eframe → floem

**Files:**
- Modify: `Cargo.toml` (workspace root)
- Modify: `crates/undone-ui/Cargo.toml`
- Modify: `src/main.rs`

**Step 1: Update workspace Cargo.toml**

Remove the `eframe` and `egui` lines from `[workspace.dependencies]` and add floem:

```toml
# GUI — replace existing eframe/egui lines with:
floem = { version = "0.1", features = ["default-font"] }
```

(Adjust version to whatever `cargo search floem` returns. Check crates.io for feature flags — `default-font` bundles a fallback font; confirm it exists in the version you use.)

**Step 2: Update `crates/undone-ui/Cargo.toml`**

Replace the `egui` and `eframe` dependency lines:

```toml
[dependencies]
undone-domain = { path = "../undone-domain" }
undone-world  = { path = "../undone-world" }
undone-scene  = { path = "../undone-scene" }
undone-packs  = { path = "../undone-packs" }
floem         = { workspace = true }
```

**Step 3: Update root `Cargo.toml` `[dependencies]` section**

Replace:
```toml
eframe = { workspace = true }
```
With:
```toml
floem = { workspace = true }
```

Remove the `anyhow` dep from root `[dependencies]` too — floem's `main` doesn't return `Result`.

**Step 4: Verify**

Run: `cargo check 2>&1 | head -40`

Expected: compile errors about `eframe`/`egui` not found in `undone-ui/src/lib.rs` and `src/main.rs`. Those are expected — we fix them in Task 2.

If floem itself fails to fetch, check crates.io name is exactly `floem`.

---

## Task 2: Minimal floem window

Replace the egui placeholder with a bare floem view that compiles and opens.

**Files:**
- Modify: `src/main.rs`
- Modify: `crates/undone-ui/src/lib.rs`

**Step 1: Rewrite `src/main.rs`**

```rust
fn main() {
    floem::launch(undone_ui::app_view);
}
```

**Step 2: Rewrite `crates/undone-ui/src/lib.rs`**

```rust
use floem::prelude::*;

pub fn app_view() -> impl View {
    label(|| "Undone is starting up.\n\nNo scene loaded yet.")
}
```

(If the floem API doesn't use `prelude::*`, check the floem README for the correct import path. The label closure syntax `|| expr` vs `move || signal.get()` may differ by version.)

**Step 3: Run cargo check**

Run: `cargo check`
Expected: clean (no errors).

**Step 4: Run the app**

Run: `cargo run`
Expected: a window opens showing the placeholder text.

**Step 5: Commit**

```bash
git add Cargo.toml crates/undone-ui/Cargo.toml crates/undone-ui/src/lib.rs src/main.rs
git commit -m "feat(ui): switch from egui/eframe to floem, minimal window"
```

---

## Task 3: Display snapshot types

Define plain Rust structs to carry display-ready strings from `World` to the UI. These are separate from the domain types — they exist so the view closures never borrow `World` directly.

**Files:**
- Modify: `crates/undone-ui/src/lib.rs` (add types at top)

**Step 1: Add `PlayerSnapshot` and `NpcSnapshot`**

```rust
/// Display-ready snapshot of the player for the stats sidebar.
#[derive(Clone, Default)]
pub struct PlayerSnapshot {
    pub name: String,
    pub femininity: i32,
    pub money: i32,
    pub stress: i32,
    pub anxiety: i32,
    pub arousal: String,   // e.g. "Comfort", "Enjoy"
    pub alcohol: String,   // e.g. "Sober", "Tipsy"
}

impl From<&undone_domain::Player> for PlayerSnapshot {
    fn from(p: &undone_domain::Player) -> Self {
        Self {
            name: p.active_name().to_owned(),
            femininity: p.femininity,
            money: p.money,
            stress: p.stress,
            anxiety: p.anxiety,
            arousal: format!("{:?}", p.arousal),
            alcohol: format!("{:?}", p.alcohol),
        }
    }
}

/// Display-ready snapshot of an active NPC.
#[derive(Clone)]
pub struct NpcSnapshot {
    pub name: String,
    pub age: String,
    pub personality: String,
    pub relationship: String,
    pub pc_liking: String,
    pub pc_attraction: String,
}

impl From<&undone_domain::NpcCore> for NpcSnapshot {
    fn from(npc: &undone_domain::NpcCore) -> Self {
        Self {
            name: npc.name.clone(),
            age: format!("{:?}", npc.age),
            personality: npc.personality.to_string(),
            relationship: format!("{:?}", npc.relationship),
            pc_liking: format!("{:?}", npc.pc_liking),
            pc_attraction: format!("{:?}", npc.pc_attraction),
        }
    }
}
```

Note: `NpcCore.personality` is a `PersonalityId` (interned string). Its `to_string()` will produce the raw interned key (e.g. `"romantic"`). That's fine for now.

**Step 2: Write unit tests for the From impls**

Add a `#[cfg(test)]` module:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::{HashMap, HashSet};
    use undone_domain::*;

    fn test_player() -> Player {
        Player {
            name_fem: "Eva".into(),
            name_androg: "Ev".into(),
            name_masc: "Evan".into(),
            before_age: 30,
            before_race: "white".into(),
            before_sexuality: Sexuality::StraightMale,
            age: Age::LateTeen,
            race: "white".into(),
            figure: PlayerFigure::Slim,
            breasts: BreastSize::MediumLarge,
            eye_colour: "blue".into(),
            hair_colour: "blonde".into(),
            traits: HashSet::new(),
            skills: HashMap::new(),
            money: 200,
            stress: 5,
            anxiety: 2,
            arousal: ArousalLevel::Comfort,
            alcohol: AlcoholLevel::Sober,
            partner: None,
            friends: vec![],
            virgin: true,
            anal_virgin: true,
            lesbian_virgin: true,
            on_pill: false,
            pregnancy: None,
            stuff: HashSet::new(),
            custom_flags: HashMap::new(),
            custom_ints: HashMap::new(),
            always_female: false,
            femininity: 25,
        }
    }

    #[test]
    fn player_snapshot_name_uses_active_name() {
        let p = test_player();
        let snap = PlayerSnapshot::from(&p);
        assert_eq!(snap.name, "Evan"); // femininity=25 → masc
    }

    #[test]
    fn player_snapshot_captures_money() {
        let p = test_player();
        let snap = PlayerSnapshot::from(&p);
        assert_eq!(snap.money, 200);
    }
}
```

**Step 3: Run tests**

Run: `cargo test -p undone-ui`
Expected: 2 tests pass.

**Step 4: Run cargo check**

Run: `cargo check`
Expected: clean.

---

## Task 4: AppSignals + two-panel layout scaffold

Define the signal bundle and implement the outer h_stack.

**Files:**
- Modify: `crates/undone-ui/src/lib.rs`

**Step 1: Add `AppSignals` struct**

```rust
use floem::reactive::RwSignal;
use undone_scene::engine::ActionView;  // Vec<ActionView> for the choices bar

/// All reactive signals used by the view tree.
#[derive(Clone, Copy)]
pub struct AppSignals {
    pub story:      RwSignal<String>,
    pub actions:    RwSignal<Vec<ActionView>>,
    pub player:     RwSignal<PlayerSnapshot>,
    pub active_npc: RwSignal<Option<NpcSnapshot>>,
}

impl AppSignals {
    pub fn new() -> Self {
        Self {
            story:      RwSignal::new(String::new()),
            actions:    RwSignal::new(Vec::new()),
            player:     RwSignal::new(PlayerSnapshot::default()),
            active_npc: RwSignal::new(None),
        }
    }
}
```

(Verify that `RwSignal` is in `floem::reactive` — may vary by version. Look at floem examples if needed.)

**Step 2: Rewrite `app_view` with two-panel scaffold**

```rust
pub fn app_view() -> impl View {
    let signals = AppSignals::new();

    h_stack((
        left_panel(signals),
        right_panel(signals),
    ))
    .style(|s| s.size_full())
}

fn left_panel(signals: AppSignals) -> impl View {
    label(|| "LEFT — story + choices")
        .style(|s| s.flex_grow(1.0))
}

fn right_panel(signals: AppSignals) -> impl View {
    label(|| "RIGHT — stats + NPC")
        .style(|s| s.width(280.0))
}
```

**Step 3: cargo check + cargo run**

Run: `cargo check && cargo run`
Expected: window opens, shows two placeholder labels side by side.

---

## Task 5: Story text panel

Implement the scrollable serif story text area (top portion of left panel).

**Files:**
- Modify: `crates/undone-ui/src/lib.rs`

**Step 1: Replace left_panel placeholder**

```rust
fn left_panel(signals: AppSignals) -> impl View {
    let story = signals.story;

    v_stack((
        scroll(
            label(move || story.get())
                .style(|s| s
                    .font_family("Georgia, 'Times New Roman', serif")
                    .font_size(17.0)
                    .line_height(1.55)
                    .padding(24.0)
                    .max_width(680.0)
                )
        )
        .style(|s| s.flex_grow(1.0)),

        choices_bar(signals),
    ))
    .style(|s| s
        .flex_grow(1.0)
        .border_right(1.0)
        .border_color(Color::rgb8(200, 200, 200))
    )
}
```

Note: floem's `.font_family()`, `.line_height()`, and `.font_size()` may have different method names — check the `Style` API in the floem source. The key values to set are:
- font: serif at 17px
- line height: ~1.55
- horizontal padding: 24px
- max-width constraint: ~680px so it doesn't stretch to full column width

**Step 2: Add placeholder choices_bar (stub)**

```rust
fn choices_bar(_signals: AppSignals) -> impl View {
    label(|| "[ no actions ]")
        .style(|s| s
            .padding(12.0)
            .border_top(1.0)
            .border_color(Color::rgb8(200, 200, 200))
            .min_height(60.0)
        )
}
```

**Step 3: Seed story signal with placeholder text for visual check**

In `app_view`, after creating signals:
```rust
signals.story.set(
    "It is a grey Tuesday morning. The rain has been falling since before you woke, \
     steady and indifferent, the kind of rain that doesn't announce itself — \
     it simply persists.\n\n\
     You stand at the bus shelter on Marchmont Street, coat pulled close, \
     watching the water sheet down the Perspex panel."
    .to_string()
);
```

**Step 4: cargo run — visual check**

Run: `cargo run`
Expected: story text displays serif, wrapped, with good line spacing. Choices bar visible at bottom.

**Step 5: Remove the placeholder seed text** (it will be replaced by actual scene content in Task 10).

---

## Task 6: Choices bar (reactive buttons)

Replace the stub choices_bar with reactive buttons that respond to `signals.actions`.

**Files:**
- Modify: `crates/undone-ui/src/lib.rs`

**Step 1: Rewrite choices_bar**

The key challenge is rendering a dynamic list of buttons. floem's API for this varies by version:
- In some versions: `dyn_stack(signal, key_fn, view_fn)`
- In others: wrap in a `container` + `create_effect`
- Simplest reliable approach: use `dyn_stack`

```rust
fn choices_bar(signals: AppSignals) -> impl View {
    let actions = signals.actions;
    // Capture game_state here (will be added in Task 10)

    let buttons = dyn_stack(
        move || actions.get(),
        |a: &ActionView| a.id.clone(),
        move |action| {
            let action_id = action.id.clone();
            let label_text = action.label.clone();
            button(label_text)
                .on_click_stop(move |_| {
                    // TODO Task 10: send ChooseAction(action_id) to engine
                    println!("action chosen: {}", action_id);
                })
                .style(|s| s
                    .margin(4.0)
                    .padding_horiz(16.0)
                    .padding_vert(8.0)
                )
        },
    )
    .style(|s| s.flex_row().flex_wrap(FlexWrap::Wrap));

    container(buttons)
        .style(|s| s
            .padding(12.0)
            .border_top(1.0)
            .border_color(Color::rgb8(200, 200, 200))
            .min_height(60.0)
            .width_full()
        )
}
```

If `dyn_stack` is not available in your floem version, check for `virtual_stack`, `dynamic_container`, or a list primitive. Look at floem's `examples/` directory for the current dynamic list API.

**Step 2: Seed actions signal with dummies for visual test**

In `app_view`:
```rust
signals.actions.set(vec![
    ActionView { id: "wait".into(), label: "Wait".into(), detail: "".into() },
    ActionView { id: "leave".into(), label: "Leave".into(), detail: "".into() },
    ActionView { id: "chat".into(), label: "Strike up a conversation".into(), detail: "".into() },
]);
```

**Step 3: cargo run — visual check**

Run: `cargo run`
Expected: three buttons appear in the choices bar, horizontally arranged. Clicking prints to console.

**Step 4: Remove the dummy seed** (will be replaced in Task 10).

---

## Task 7: PC stats sidebar

**Files:**
- Modify: `crates/undone-ui/src/lib.rs`

**Step 1: Add `stat_row` helper**

```rust
fn stat_row(label_text: &'static str, value_fn: impl Fn() -> String + 'static) -> impl View {
    h_stack((
        label(label_text)
            .style(|s| s
                .flex_grow(1.0)
                .color(Color::rgb8(130, 130, 130))
                .font_size(13.0)
            ),
        label(value_fn)
            .style(|s| s.font_size(13.0)),
    ))
    .style(|s| s.margin_bottom(4.0))
}
```

**Step 2: Add `stats_panel` function**

```rust
fn stats_panel(player: RwSignal<PlayerSnapshot>) -> impl View {
    v_stack((
        label(move || player.get().name)
            .style(|s| s
                .font_bold()
                .font_size(14.0)
                .padding_bottom(10.0)
            ),
        stat_row("Femininity", move || player.get().femininity.to_string()),
        stat_row("Money",      move || format!("£{}", player.get().money)),
        stat_row("Stress",     move || player.get().stress.to_string()),
        stat_row("Anxiety",    move || player.get().anxiety.to_string()),
        stat_row("Arousal",    move || player.get().arousal.clone()),
        stat_row("Alcohol",    move || player.get().alcohol.clone()),
    ))
    .style(|s| s.padding(16.0))
}
```

**Step 3: Update right_panel**

```rust
fn right_panel(signals: AppSignals) -> impl View {
    v_stack((
        stats_panel(signals.player),
        npc_panel(signals.active_npc),  // stub from Task 8
    ))
    .style(|s| s
        .width(280.0)
        .border_left(1.0)
        .border_color(Color::rgb8(200, 200, 200))
    )
}
```

**Step 4: Seed player signal**

In `app_view`:
```rust
signals.player.set(PlayerSnapshot {
    name: "Evan".into(),
    femininity: 15,
    money: 340,
    stress: 22,
    anxiety: 8,
    arousal: "Comfort".into(),
    alcohol: "Sober".into(),
});
```

**Step 5: cargo run — visual check**

Expected: right sidebar shows name + stat rows with correct layout.

---

## Task 8: NPC panel (conditional)

**Files:**
- Modify: `crates/undone-ui/src/lib.rs`

**Step 1: Add `npc_panel` function**

The key challenge: show panel only when `active_npc` is `Some(...)`. Use floem's conditional rendering.

```rust
fn npc_panel(active_npc: RwSignal<Option<NpcSnapshot>>) -> impl View {
    // floem approach: use `dyn_view` or `show_if` depending on version
    // Pattern that works across versions: compute a string and show/hide

    container(
        dyn_view(move || {
            if let Some(npc) = active_npc.get() {
                v_stack((
                    label(move || format!("── {} ──", npc.name.clone()))
                        .style(|s| s.font_bold().font_size(13.0).padding_bottom(8.0)),
                    stat_row("Age",          move || npc.age.clone()),
                    stat_row("Personality",  move || npc.personality.clone()),
                    stat_row("Relationship", move || npc.relationship.clone()),
                    stat_row("Liking",       move || npc.pc_liking.clone()),
                    stat_row("Attraction",   move || npc.pc_attraction.clone()),
                ))
                .into_any()
            } else {
                empty().into_any()
            }
        })
    )
    .style(|s| s
        .padding(16.0)
        .border_top(1.0)
        .border_color(Color::rgb8(200, 200, 200))
    )
}
```

Note: `dyn_view` / `into_any()` API may differ. In some floem versions it's `dynamic_container(signal, render_fn)`. Check floem's conditional rendering examples. The key pattern: return different view types via `into_any()` boxing.

**Step 2: Visual check — NPC absent**

Leave `active_npc` as `None` (default). Run `cargo run`.
Expected: NPC panel area is empty (just the border).

**Step 3: Visual check — NPC present**

Seed in `app_view`:
```rust
signals.active_npc.set(Some(NpcSnapshot {
    name: "James".into(),
    age: "Twenties".into(),
    personality: "romantic".into(),
    relationship: "Acquaintance".into(),
    pc_liking: "Neutral".into(),
    pc_attraction: "Ok".into(),
}));
```

Run: `cargo run`.
Expected: NPC panel appears in right sidebar below stats.

**Step 4: Remove seed values** (all dummy seeds removed from `app_view`).

**Step 5: Commit layout**

```bash
git add crates/undone-ui/src/lib.rs
git commit -m "feat(ui): two-panel layout with story text, choices bar, PC stats, NPC panel"
```

---

## Task 9: GameState struct + game init

Wire the real game into the UI. After this task, the app boots into a real `new_game()` state.

**Files:**
- Modify: `crates/undone-ui/src/lib.rs`

**Step 1: Add `GameState` struct**

```rust
use std::{rc::Rc, cell::RefCell};
use undone_world::World;
use undone_packs::PackRegistry;
use undone_scene::engine::{SceneEngine, EngineCommand, EngineEvent};

pub struct GameState {
    pub world: World,
    pub registry: PackRegistry,
    pub engine: SceneEngine,
}
```

**Step 2: Add `init_game()` function**

This loads all packs and creates the initial world state.

Actual API (verified from source):
- `load_packs(packs_dir: &Path) -> Result<(PackRegistry, Vec<LoadedPackMeta>), PackLoadError>` — takes the whole `packs/` directory, loads all subdirs
- `new_game(config: CharCreationConfig, registry: &mut PackRegistry, rng: &mut R) -> World` — needs an explicit config and RNG
- `load_scenes(scenes_dir: &Path, registry: &PackRegistry) -> Result<HashMap<...>, SceneLoadError>`

```rust
fn init_game() -> GameState {
    use rand::{rngs::SmallRng, SeedableRng};
    use undone_domain::{Age, BreastSize, PlayerFigure, Sexuality};
    use undone_packs::{load_packs, char_creation::{new_game, CharCreationConfig}};
    use undone_scene::loader::load_scenes;

    let packs_dir = std::path::Path::new("packs");

    // Load all packs from packs/ directory
    let (mut registry, metas) = match load_packs(packs_dir) {
        Ok(r) => r,
        Err(e) => {
            eprintln!("[init] pack load error: {e}");
            // Fall back to empty registry + no scenes — app will show no content
            return GameState {
                world: undone_world::World {
                    player: placeholder_player(),
                    male_npcs: slotmap::SlotMap::with_key(),
                    female_npcs: slotmap::SlotMap::with_key(),
                    game_data: undone_world::GameData::default(),
                },
                registry: undone_packs::PackRegistry::new(),
                engine: SceneEngine::new(std::collections::HashMap::new()),
            };
        }
    };

    // Placeholder character — real char creation screen is a future session
    let config = CharCreationConfig {
        name_fem: "Eva".into(),
        name_androg: "Ev".into(),
        name_masc: "Evan".into(),
        age: Age::EarlyTwenties,
        race: "white".into(),
        figure: PlayerFigure::Slim,
        breasts: BreastSize::MediumLarge,
        always_female: false,
        before_age: 28,
        before_race: "white".into(),
        before_sexuality: Sexuality::StraightMale,
        starting_traits: vec![],
        male_count: 6,
        female_count: 2,
    };

    let mut rng = SmallRng::from_entropy();
    let world = new_game(config, &mut registry, &mut rng);

    // Load scenes from the base pack's scenes directory.
    // PackManifest uses manifest.pack.id; scenes path from manifest.content.scenes_dir.
    let scenes = metas.iter()
        .find(|m| m.manifest.pack.id == "base")
        .and_then(|m| {
            let scene_dir = m.pack_dir.join(&m.manifest.content.scenes_dir);
            load_scenes(&scene_dir, &registry).ok()
        })
        .unwrap_or_default();

    let engine = SceneEngine::new(scenes);
    GameState { world, registry, engine }
}
```

`placeholder_player()` is a small private helper that creates a bare `Player` with sensible defaults for the error branch — copy from the test helpers in `undone-scene/src/engine.rs`.

**Step 3: Integrate into `app_view`**

```rust
pub fn app_view() -> impl View {
    let signals = AppSignals::new();

    let state = Rc::new(RefCell::new(init_game()));

    // Populate initial player snapshot
    {
        let gs = state.borrow();
        signals.player.set(PlayerSnapshot::from(&gs.world.player));
    }

    h_stack((
        left_panel(signals, Rc::clone(&state)),
        right_panel(signals),
    ))
    .style(|s| s.size_full())
}
```

Update `left_panel` signature to accept `Rc<RefCell<GameState>>`:
```rust
fn left_panel(signals: AppSignals, state: Rc<RefCell<GameState>>) -> impl View {
    // pass state down to choices_bar
    ...
}
```

**Step 4: cargo check**

Run: `cargo check`
Expected: clean (or errors that reveal real signature mismatches — fix per actual API).

---

## Task 10: Scene event loop — wire engine to signals

After this task, clicking a choice updates the story text. The game runs.

**Files:**
- Modify: `crates/undone-ui/src/lib.rs`

**Step 1: Add `process_events()` helper**

```rust
fn process_events(events: Vec<EngineEvent>, signals: AppSignals, world: &World) {
    for event in events {
        match event {
            EngineEvent::ProseAdded(text) => {
                signals.story.update(|s| {
                    if !s.is_empty() {
                        s.push_str("\n\n");
                    }
                    s.push_str(&text);
                });
            }
            EngineEvent::ActionsAvailable(actions) => {
                signals.actions.set(actions);
            }
            EngineEvent::SceneFinished => {
                signals.actions.set(vec![]);
                // Scheduler integration: future session will pick next scene
            }
        }
    }
    signals.player.set(PlayerSnapshot::from(world));
}
```

**Step 2: Start opening scene on app launch**

After `init_game()` in `app_view`, start the base pack's opening scene:

```rust
{
    let mut gs = state.borrow_mut();
    gs.engine.send(
        EngineCommand::StartScene("base::rain_shelter".into()),
        &mut gs.world,
        &gs.registry,
    );
    let events = gs.engine.drain();
    process_events(events, signals, &gs.world);
}
```

(Scene ID `base::rain_shelter` — verify this matches the scene file in `packs/base/scenes/`.)

**Step 3: Wire button clicks to engine**

In `choices_bar`, replace the `println!` stub:

```rust
let state_clone = Rc::clone(&state);
let signals_clone = signals;
button(label_text)
    .on_click_stop(move |_| {
        let mut gs = state_clone.borrow_mut();
        gs.engine.send(
            EngineCommand::ChooseAction(action_id.clone()),
            &mut gs.world,
            &gs.registry,
        );
        let events = gs.engine.drain();
        process_events(events, signals_clone, &gs.world);
    })
```

Note: `Rc<RefCell<...>>` requires `state_clone` to be captured by `move` closure. Each button closure gets its own `Rc::clone`.

**Step 4: cargo run — smoke test**

Run: `cargo run`
Expected:
- Window opens
- Rain shelter scene intro prose appears in story text area (serif, line-spaced)
- Two or more action buttons appear in choices bar
- Clicking an action appends prose and updates available choices
- Player stats sidebar shows real values

**Step 5: Commit**

```bash
git add crates/undone-ui/src/lib.rs src/main.rs Cargo.toml crates/undone-ui/Cargo.toml
git commit -m "feat(ui): wire scene engine to floem signals, game runs end-to-end"
```

---

## Task 11: Cleanup and finishing

**Step 1: Remove all egui/eframe imports from anywhere**

```bash
cargo check 2>&1 | grep -i "unused\|eframe\|egui"
```

**Step 2: Format all modified files**

Use MCP tools after each file is written:
- `mcp__rust__format_code` on `crates/undone-ui/src/lib.rs` and `src/main.rs`

**Step 3: Run full test suite**

```bash
cargo test
```

Expected: all 85 pre-existing tests pass. UI crate tests (PlayerSnapshot conversions) also pass.

**Step 4: cargo clippy**

```bash
cargo clippy -- -D warnings
```

Fix any warnings before continuing.

**Step 5: Update HANDOFF.md**

Update Current State section and add a session log entry:
- floem migration done
- layout implemented (two-panel, story text, choices bar, PC stats, NPC panel)
- game boots and runs rain-shelter scene end-to-end
- Next: Writing guide session

**Step 6: Invoke superpowers:finishing-a-development-branch**

---

## floem API Quick Reference

Likely imports (verify against actual floem version):

```rust
use floem::prelude::*;           // Views, style methods
use floem::reactive::RwSignal;   // Signals
use floem::views::{
    label, button, scroll, h_stack, v_stack,
    container, empty, dyn_stack, dyn_view,
};
use floem::style::{FlexWrap, Style};
use floem::peniko::Color;
```

If any of these don't resolve, check:
1. `floem/src/views/mod.rs` for exported view constructors
2. `floem/src/reactive/mod.rs` for signal types
3. `floem/examples/` for working patterns

The floem source is the ground truth. The plan's code snippets are guidance — adapt to the actual installed version.

---

## What this session does NOT do

- Font loading from disk (system fonts only — a future polish task)
- Scheduler integration (SceneFinished just clears actions for now)
- Save/load button (future task)
- Character creation screen (future task)
- Scroll-to-bottom on new prose (nice-to-have, add if easy)
